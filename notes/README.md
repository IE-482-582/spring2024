# Class Notes
We'll add to this document as we progress through the semester.

---

## 1 - Viewing a simulated "Husky" robot
- See https://www.clearpathrobotics.com/assets/guides/noetic/husky/InterfacingWithHusky.html#visualization

### Start Husky Gazebo simulation:	
In Terminal 1:
```
roslaunch husky_gazebo husky_playpen.launch
```
- You can also try `roslaunch husky_gazebo empty_world.launch`, but it's pretty boring.

In Terminal 2:
```
roslaunch husky_viz view_robot.launch 
```

#### Notes:
- By default, the Husky does not publish scan or camera data.
- Take a look at `/opt/ros/noetic/share/husky_description/urdf/husky.urdf.xacro` (DO. NOT. EDIT. THIS. FILE.)
    ```
    pico /opt/ros/noetic/share/husky_description/urdf/husky.urdf.xacro 
    ```
    - `ctrl` + `x` to exit
      
- To get front/rear scanners and an RGBD camera, make sure the following environment variables are set in `~/.bashrc`:	
    ```
    export HUSKY_LMS1XX_ENABLED=1
    export HUSKY_LMS1XX_SECONDARY_ENABLED=1
    export HUSKY_REALSENSE_ENABLED=1
    export HUSKY_REALSENSE_XYZ="0.31 0 0"
    ```

    ```
    pico ~/.bashrc
    ```
    - `ctrl` + `o` to save/output
    - `ctrl` + `x` to exit

### View data in RViz	
- camera
- scan
- odom
	
The data we're visualizing here is actually being "published" by our simulated robot. 

### List topics	
```
rostopic list
```
- camera, scan, GPS, 
	
With ROS, it is possible to observe the stream of raw data directly from the terminal.
```
# Echo topic data	
rostopic echo /front/scan
```

ROS "Topics" use a publish/subscribe model/paradigm.
- publish vs subscribe	The Husky posts some data, it listens for some data
    - See `/cmd_vel`
	
ROS "Nodes"
We can visualize ROS info with `rqt`:
```
rqt
```
- plugins -> node graph


    
### Summary
What did we just see?
- Gazebo is a physics-based simulation engine
- RViz makes it easy to view the data being generated by the robot (either a real robot or a simulated robot)
- Our robot publishes data, and it also listens for data


### Before Next Class
- ~~Read~~ Study textbook Chapter 1
- Scroll through the ROS tutorials website:  http://wiki.ros.org/ROS/Tutorials
    - You don't have to do any of the tutorials yet, just take a look at the materials.

---

## 2 - Make our Husky Move
Let's see all of the topics currently being published:
```
rostopic list
```

Our Husky listens to (or, is "subscribed" to) the `cmd_vel` topic.  Let's get some information on that topic:
```
rostopic info cmd_vel
```

This produces:
```
Type: geometry_msgs/Twist
 
Publishers: None
   
Subscribers: 
* /twist_mux (http://192.168.0.209:36683/)
```

The topic "type" specifies the structure of the information being passed between "nodes".  To view the structure of the `geometry_msgs/Twist` topic type:
```
rosmsg show geometry_msgs/Twist
```

This produces:
```
geometry_msgs/Vector3 linear
  float64 x
  float64 y
  float64 z
geometry_msgs/Vector3 angular
  float64 x
  float64 y
  float64 z
```

We can publish topics directly from the terminal (command line).  
The general form is:
    - `rostopic pub /the_topic_name the_topic_type [args]`
For the Husky `cmd_vel` topic, the specific command is:    
    - `rostopic pub -r 10 /cmd_vel geometry_msgs/Twist  '{linear:  {x: 0.1, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}'`    
    
This isn't a great way to control our robot.

Let's look at some better ways.  In each of the following approaches, we're going to have some code running in the background to capture commands and send them to the robot.
This "code running in the background" is called a "node".  
A "node" is typically written in either C++ or Python.  In this class, we use Python exclusively.
- So, you can think of a node as being just a Python script that interacts with ROS.

Here's Python code for a node that publishes Twist commands randomly, every x seconds:
```
#!/usr/bin/env python3

import random
import rospy
from geometry_msgs.msg import Twist


class Publisher():
	def __init__(self):
	
		rospy.init_node("cmd_vel_publisher")

		self.cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=1)
		self.twist = Twist()

		self.rate = rospy.Rate(1/5)	# [Hz]

		self.run()
		
	def createTwistMsg(self):
		msg = Twist()
		msg.linear.x  = random.random()*5
		msg.angular.z = random.random()*5
		return msg
		
	def run(self):
		count = 0
		while count < 10:

			cmd = self.createTwistMsg()
      print(cmd)
			self.cmd_vel_pub.publish(cmd)
			
			count += 1
			
			self.rate.sleep()
			
			
if __name__ == "__main__":
	Publisher()
```

### Before Next Class
- ~~Read~~ Study textbook Chapter 2
- Continue to scroll through the ROS tutorials website:  http://wiki.ros.org/ROS/Tutorials
    - You don't have to do any of the tutorials yet, just take a look at the materials.
- Create a 1-page Linux "cheat sheet".
    - You are strongly encouraged to find good examples online (be sure to give credit to those that inspire you)
    - Please don't include ROS commands on your sheet.  We'll have a separate ROS cheat sheet later.
    - Take a look in your previous commands to see some of those we've used this semester.  `pico ~/.bash_history`.
 

---

## 3 - Networking

- Make sure your VM is setup for "bridged" network adapter.
- Connect to the class Wi-Fi network, with password `ros4ever!`, from your **host** computer (not from your Ubuntu VM).
- One computer in the network needs to be running `roscore`.  This computer is known as the "ROS master".  You will need to know its IP address.
    - Once you know the IP address of the "ROS master", issue the following command in a Ubuntu terminal:
        ```
        export ROS_MASTER_URI="http://192.168.0.xxx:11311"
        ```
        - Replace `xxx` as appropriate

    - To find **your** computer's IP address, issue this command from an Ubuntu terminal:  `ifconfig`.
- Type `rostopic list` to see if you are connected

---

## 4 - Teleoperation

"Teleoperation" refers to remote control of a vehicle/robot.  We will explore several different teleop approaches:
- Keyboard control
- Joystick control
- Custom Web (HTML/JavaScript) interface

#### Keyboard Control
We will make use of the existing `teleop_twist_keyboard` package.
- See https://github.com/ros-teleop/teleop_twist_keyboard for documentation
- If you don't already have a robot running, you can start one like this:
    ```
    roslaunch husky_gazebo empty_world.launch
    ```

To use the default settings, open a new terminal window and type:
```
rosrun teleop_twist_keyboard teleop_twist_keyboard.py
``` 

Better yet, pass some custom parameter values, like this:
```
rosrun teleop_twist_keyboard teleop_twist_keyboard.py _repeat_rate:=10.0 _key_timeout:=0.6 cmd_vel:=my_cmd_vel _speed:=0.9 _turn:=0.8
```
This will set the following parameter values:
- `repeat_rate`: How fast, in Hz, that the last command is repeated.  Default is `0.0` (no repeat)
- `key_timeout`: How long, in seconds, that the system will wait for another keypress before giving up.
    - From the documentation:  "It is recommended that you set `key_timeout` higher than the initial key repeat delay on your system (This delay is 0.5 seconds by default on Ubuntu, but can be adjusted)."
- `cmd_vel`:  Name of topic to be published.  Default is `cmd_vel`.
    - NOTE:  I don't see how this actually has an impact, but it appears to work as advertised.  See https://github.com/ros-teleop/teleop_twist_keyboard/blob/master/teleop_twist_keyboard.py 
- `speed` and `turn`:  Values for `linear.x` and `angular.z`, respectively. 

Why are there things after the name of the Python script that start with an underscore and include the "walrus operator" (`:=`)?
This actually lets us set variables in the Python script, using `rospy.get_param("~<parametername>", <defaultvalue>)`.
Let's take a look at the `teleop_twist_keyboard.py` script (see https://github.com/ros-teleop/teleop_twist_keyboard/blob/master/teleop_twist_keyboard.py).
You'll see the following:
```
speed = rospy.get_param("~speed", 0.5)
turn = rospy.get_param("~turn", 1.0)
speed_limit = rospy.get_param("~speed_limit", 1000)
turn_limit = rospy.get_param("~turn_limit", 1000)
repeat = rospy.get_param("~repeat_rate", 0.0)
key_timeout = rospy.get_param("~key_timeout", 0.5)
```
In the command line, the parameter starts with a `_`; in the Python script, replace the leading `_` with a `~`.


#### Joystick Control
We will explore the following together in class:
- https://wiki.ros.org/teleop_twist_joy
- https://wiki.ros.org/joy
- https://docs.ros.org/en/api/joy/html/

These require a physical joystick (like a PlayStation or XBox controller).

- (placeholder here to document where the `joy` node is saved, how Husky starts it, and how you might start it for other projects.)

#### Custom Controller
- (placeholder here for example code)


## 5 - Autonomous Navigation

We will start by controlling our Husky, but these navigation tools are more broadly applicable.

- Move Base:  https://www.clearpathrobotics.com/assets/guides/noetic/husky/HuskyMove.html
    - http://wiki.ros.org/move_base

- AMCL: https://www.clearpathrobotics.com/assets/guides/noetic/husky/HuskyAMCL.html
    - http://wiki.ros.org/amcl

- Gmapping: https://www.clearpathrobotics.com/assets/guides/noetic/husky/HuskyGmapping.html
    - http://wiki.ros.org/gmapping 

### Further Reading:
- http://wiki.ros.org/navigation
- http://wiki.ros.org/navigation/Tutorials **CHECK THIS OUT**


--- 


## 6 - Building a ROS Package
In this lesson we will build our own ROS package.  

Why do we need to create a package?  Why not just run our Python scripts from some random directory?
1. Packages are a nice way to organize your code, especially if you're working on a project.
2. If you want to create customized topics or services, you'll need to create a package.

To get a better understanding of how to build a package, we're going to create a project for a collection of turtlebots, each with a unique ID.  The turtlebots will be looking for aruco tags.  When they find one, they will report the tag ID and the location of the tag.  The message will carry this information:
- The ID of each turtlebot.  We'll call this `robotID`.  It will be an integer.
- The ID of each discovered aruco tag.  Each tag has an integer ID.  There might be several tags discovered at once.
- The location of each aruco tag (`x`, `y`, and `z` floating point coordinates).

There is not an existing ROS message definition that has these fields.

Let's build our package, which we'll call `turtletag`.  

### 1.  Create the Package
```
cd ~/catkin_ws/src
catkin_create_pkg turtletag
```

- This will create the `~/catkin_ws/src/turtletag` directory, which will be pre-populated with 2 files:  `CMakeLists.txt` and `package.xml`
    - We'll come back to these files shortly.
    

### 2.  Structure/Organize the Package
We'll create some directories to help keep our code organized:
```
cd ~/catkin_ws/src/turtletag
mkdir scripts    # Where our Python code (nodes) will go
mkdir msg        # Where we'll save our custom message definitions
mkdir launch     # Where we'll save .launch files
```
- If we had custom services, we'd also run `mkdir srv`.
    
### 3.  Create our Custom Message Definition

We will name our tag-locating message `tagloc.msg`.  It will be saved as `~/catkin_ws/src/turtletag/msg/tagloc.msg`.  Let's open a text editor to create the message:
```
cd ~/catkin_ws/src/turtletag/msg
pico tagloc.msg
```

In the text editor, write the following:
```
int32 robotID
int32 tagID
geometry_msgs/Point position
```

- See https://docs.ros.org/en/noetic/api/geometry_msgs/html/msg/Point.html.  You can find `Point.msg` if you run `roscd geometry_msgs/msg`.
- `geometry_msgs/Point` has this structure:
    ```
    # This contains the position of a point in free space
    float64 x
    float64 y
    float64 z
    ```

### 4. Finish Configuring our Package
There are two files that we need to edit:
#### `package.xml`
Run `pico ~/catkin_ws/src/turtletag/package.xml`

Scroll down to where you see the `<buildtool_depend>catkin</buildtool_depend>` line.  Paste the following after that line:

```
  <depend>roscpp</depend>
  <depend>rospy</depend>
  <depend>std_msgs</depend>
  <depend>geometry_msgs</depend>

  <build_export_depend>message_generation</build_export_depend>
  <exec_depend>message_runtime</exec_depend>
```


#### `CMakeLists.txt`
You'll need to follow these instructions **very carefully**.  There are many sections of the file that look quite similar.  Make sure things match **exactly**.

1.  Find the line that reads `find_package(catkin REQUIRED)`  (**exactly like this**), and replace it as follows:
    ```
    find_package(catkin REQUIRED COMPONENTS
      roscpp
      rospy
      std_msgs
      geometry_msgs
      message_generation
    )
    ```
    
2.  Find the block that reads **exactly** as:
    ```
    # add_message_files(
    #   FILES
    #   Message1.msg
    #   Message2.msg
    # )
    ```

    Replace this block with:

    ```
    add_message_files(
      FILES
      tagloc.msg
    )
    ```
    
3.  Find the block that reads **exactly** as:
    ```
    # generate_messages(
    #   DEPENDENCIES
    #   std_msgs  # Or other packages containing msgs
    # )
    ```

    Replace this block with:

    ```
    generate_messages(
      DEPENDENCIES
      std_msgs
      geometry_msgs
    )
    ```        
    
4.  Find the block that reads **exactly** as:   
    ```
    catkin_package(
    #  INCLUDE_DIRS include
    #  LIBRARIES turtletag
    #  CATKIN_DEPENDS other_catkin_pkg
    #  DEPENDS system_lib
    )
    ```

    Replace this block with:

    ```
    catkin_package(
    #  INCLUDE_DIRS include
    #  LIBRARIES gcs
       CATKIN_DEPENDS roscpp rospy std_msgs geometry_msgs message_runtime
    #  DEPENDS system_lib
    )
    ```
    
5.  Find the block that reads **exactly** as:   
    ```
    include_directories(
    # include
    # ${catkin_INCLUDE_DIRS}
    )
    ```

    Replace this block with:

    ```
    include_directories(
      ${catkin_INCLUDE_DIRS}
    )    
    ```    

Save the file.


### 5. Recompile (make) our Package
Now we need to compile the package so ROS knows about our custom message definition (and all the other things our package depends on):
```
cd ~/catkin_ws
catkin_make
```



### 6.  Testing
Let's see if we can now generate a `tagloc` message in Python.

First, open a Python terminal:
```
python3
```

Now, type the following:
```
from turtletag.msg import tagloc

myMsg = tagloc()

myMsg
```

You should see
> ```
> robotID: 0
> tagID: 0
> position: 
>   x: 0.0
>   y: 0.0
>   z: 0.0
> ```


**Summary**:  We covered the steps for creating a ROS package, which was motivated by our need for a message type that doesn't natively exist in ROS.


### Further Reading
- https://wiki.ros.org/ROS/Tutorials/CreatingPackage
    - https://wiki.ros.org/catkin/CMakeLists.txt
- https://wiki.ros.org/ROS/Tutorials/BuildingPackages
- See Chapter 3
- https://wiki.ros.org/msg

---

## 7 - An intro to launch files

"Launch Files" provide an organized way of starting `roscore`, Gazebo, and multiple nodes simultaneously.  They provide a nice alternative to the process of opening a separate terminal window for each ROS-related command.

Here's an example where we use a launch file to
- Start a Gazebo world;
- Spawn 2 turtlebot robots; and
- Start a Python node.

Save the following as `~/catkin_ws/src/turtletag/launch/demo.launch`:

```
<?xml version="1.0"?>
<launch>
  <arg name="gui" default="true" doc="Show GUI? [true, false]"/>
  <arg name="headless" default="false" doc="Headless? [true, false]"/>  <!-- I don't think this actually does anything -->

  <include file="$(find gazebo_ros)/launch/empty_world.launch">
	<arg name="world_name" value="$(find turtlebot3_gazebo)/worlds/turtlebot3_autorace.world"/>
				  	
    <arg name="paused" value="false"/>
    <arg name="use_sim_time" value="true"/>
    <arg name="gui" value="$(arg gui)"/>
    <arg name="headless" value="$(arg headless)"/>
    <arg name="debug" value="false"/>
  </include>
  
  <arg name="first_tb3"       default="tb3_1"/>  <!-- Each name must be unique -->
  <arg name="first_tb3_model" default="$(env TURTLEBOT3_MODEL)" doc="model type [burger, waffle, waffle_pi]"/>
  <arg name="first_tb3_x"     default=" 0.656"/>
  <arg name="first_tb3_y"     default=" 1.572"/>
  <arg name="first_tb3_z"     default=" 0.0"/>
  <arg name="first_tb3_yaw"   default="-1.57"/>
  <arg name="first_tb3_cam"   default="$(arg first_tb3)/camera/rgb/image_raw"/>

  <arg name="second_tb3"       default="tb3_2"/>  <!-- Each name must be unique -->
  <arg name="second_tb3_model" value="burger"/>   <!-- Here we'll just hard-code the model type -->  
  <arg name="second_tb3_x"     default=" 1.159"/>
  <arg name="second_tb3_y"     default=" 1.524"/>
  <arg name="second_tb3_z"     default=" 0.0"/>
  <arg name="second_tb3_yaw"   default="-1.57"/>
  <arg name="second_tb3_cam"   default="$(arg second_tb3)/camera/rgb/image_raw"/>
  
  
  <group ns = "$(arg first_tb3)">
    <param name="robot_description" 
     command="$(find xacro)/xacro $(find turtlebot3_description)/urdf/turtlebot3_$(arg first_tb3_model).urdf.xacro" />

    <node pkg="robot_state_publisher" type="robot_state_publisher" name="robot_state_publisher" output="screen">
      <param name="publish_frequency" type="double" value="50.0" />
      <param name="tf_prefix" value="$(arg first_tb3)" />
    </node>

    <node name="spawn_urdf" pkg="gazebo_ros" type="spawn_model" 
     args="-urdf -model $(arg first_tb3) -x $(arg first_tb3_x) -y $(arg first_tb3_y) -z $(arg first_tb3_z) -Y  $(arg first_tb3_yaw) -param robot_description" />
  </group>

  <group ns = "$(arg second_tb3)">
    <param name="robot_description" 
    command="$(find xacro)/xacro $(find turtlebot3_description)/urdf/turtlebot3_$(arg second_tb3_model).urdf.xacro" />

    <node pkg="robot_state_publisher" type="robot_state_publisher" name="robot_state_publisher" output="screen">
      <param name="publish_frequency" type="double" value="50.0" />
      <param name="tf_prefix" value="$(arg second_tb3)" />
    </node>

    <node name="spawn_urdf" pkg="gazebo_ros" type="spawn_model" args="-urdf -model $(arg second_tb3) -x $(arg second_tb3_x) -y $(arg second_tb3_y) -z $(arg second_tb3_z) -Y $(arg second_tb3_yaw) -param robot_description" />
  </group>
  
  <node name="view_camera_first_tb3" pkg="followbot" type="view_camera.py" respawn="false">
		<param name="camTopic" value="$(arg first_tb3_cam)" />
  </node>

  <node name="view_camera_second_tb3" pkg="followbot" type="view_camera.py" respawn="false">
		<param name="camTopic" value="$(arg second_tb3_cam)" />
  </node>

</launch>
```

Run this as
```
roslaunch turtletag demo.launch
```


### Resources
- Install the `ub_gazebo` package:  https://github.com/optimatorlab/ub_gazebo

- https://wiki.ros.org/roslaunch
    - https://wiki.ros.org/roslaunch/XML
    - https://wiki.ros.org/roslaunch/XML/node
- http://www.clearpathrobotics.com/assets/guides/noetic/ros/Launch%20Files.html
- https://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch
    - https://wiki.ros.org/ROS/Tutorials/Roslaunch%20tips%20for%20larger%20projects
- A nice example here, launching a python node:
    - https://github.com/duckietown/dt-core/blob/daffy/packages/apriltag/launch/apriltag_detector_node.launch

### Exercises
1.  Change `demo.launch` to spawn a different world that is already on your computer.
    - See `/usr/share/gazebo-11/worlds` or `roscd husky_gazebo/worlds/`
2.  Launch Gazebo without the Gazebo GUI.  This is sometimes called "headless", although the `headless` arg in the launchfile is deprecated.
3.  Create a simple ROS node that simply publishes a text string (`std_msgs/String`) at a rate of 1Hz.  Then, modify `demo.launch` to start your node.
    - Use `rostopic echo <your topic name>` to verify that your node is running properly.

--- 

## 8 - Gazebo Worlds 
The easiest way to open a Gazebo world is to use the `gazebo <worldname>` command (replacing `<worldname>` with the name of an actual `.world` file).  For example:
```
gazebo worlds/simple_arm.world
```

When you run the `gazebo` command, Gazebo will search for worlds found in your `GAZEBO_RESOURCE_PATH` environment variable.  What's in that?
```
echo $GAZEBO_RESOURCE_PATH
```

There are several worlds already available on your machine:
- `cd /usr/share/gazebo-11/worlds`
- `cd ~/catkin_ws/src/turtlebot3_simulations/turtlebot3_gazebo/worlds` 
- `roscd husky_gazebo/worlds/`


You may also find some resources online.  For example:
- https://app.gazebosim.org/fuel/worlds  
    - **Do these work with Gazebo "classic"?** If so, this is an amazing resource.
- https://docs.px4.io/main/en/sim_gazebo_classic/worlds.html

--- 

Another common way of opening a Gazebo world is with a `.launch` file.   

- There are several launch files pre-installed with `gazebo_ros`:
    ```
    roscd gazebo_ros/launch
    ```
- If you have `turtlebot3_gazebo` installed:
    ```
    roscd turtlebot3_gazebo/launch
    ```
- If you have `husky_gazebo` installed:
    ```
    roscd husky_gazebo/launch
    ```
    
If you open any of the `.launch` files found above, you'll see that they reference one or more `.world` files.
- NOTE: The above `.launch` files are for use with Gazebo (note the package names).
- Not all ROS `.launch` files spawn Gazebo, though.
    - If you have a ROS-enabled real/physical robot, it likely uses a `.launch` file to start its various nodes, but it won't have any need for Gazebo.
- `.launch` files are particularly useful if you're trying to spawn one or more robots, or to start one or more ROS nodes.
    - If you're simply starting a Gazebo world, the `gazebo <worldname>` is going to be your best option.


### Building your own world
This tutorial provides an introduction into creating a world within Gazebo:
- https://classic.gazebosim.org/tutorials?tut=build_world

The resulting world is a `.sdf` file; you may change its extension to `.world` after saving.


### Resources
- https://classic.gazebosim.org/tutorials?tut=components
- https://classic.gazebosim.org/tutorials?tut=ros_roslaunch
- http://wiki.ros.org/urdf/Tutorials
- https://classic.gazebosim.org/tutorials?tut=model_editor&cat=model_editor_top#Savingyourmodel

### Exercises
1.  Spawn an existing world (other than what we did above) that is already on your computer.
2.  Spawn a world (any world except those in the `husky_gazebo` package) with a Husky in it.
3.  Spawn a world (any world except those in the `turtlebot3_gazebo` package) with a turtlebot in it.
4.  (group exercise) Create a world of 427 Bell.
    - [ ] Use floorplan to get wall locations
    - [ ] Shiny black tiles
    - [ ] Windows
    - [ ] Lights and ceiling tiles
    - [ ] Tables
    - [ ] Chairs
    - [ ] UR5 robot on pedastal
    - [ ] ...
    
---

## 9 - URDF and SDF 
URDF is the "universal robotic description format".  A URDF file of a robot can describe the location of onboard sensors, the size of the robot's wheelbase, the radius of its wheels, the inertia of its arms, and the joints between its component parts. 
The URDF file can be used by Gazebo for simulated robots, but is also useful on real robots.  

URDF files are often combined with ROS's "xacro" macro language, which can reduce filesizes and make it easier to customize/parameterize robot characteristics.

The "simulation description format" (SDF) is the current preferred way of modeling objects (like tables, walls, trees, etc., as opposed to robots) in simulation.  An SDF file of an object will describe its visual properties, the volume of the object that will interact with other objects in a "collision", the material of the object, links and joints, and friction.

Both URDF and SDF use XML syntax.  

### Example 1 - Turtlebot

Let's see how URDF files are used with a simulated turtlebot3:

```
roscd turtlebot3_gazebo
cd launch
pico turtlebot3_world.launch
```

```
<launch>
  <arg name="model" default="$(env TURTLEBOT3_MODEL)" doc="model type [burger, waffle, waffle_pi]"/>
  <arg name="x_pos" default="-2.0"/>
  <arg name="y_pos" default="-0.5"/>
  <arg name="z_pos" default="0.0"/>

  <include file="$(find gazebo_ros)/launch/empty_world.launch">
    <arg name="world_name" value="$(find turtlebot3_gazebo)/worlds/turtlebot3_world.world"/>
	<!-- removed some stuff to save space -->
  </include>

  <param name="robot_description" command="$(find xacro)/xacro $(find turtlebot3_description)/urdf/turtlebot3_$(arg model).urdf.xacro" />

  <node pkg="gazebo_ros" type="spawn_model" name="spawn_urdf"  args="-urdf -model turtlebot3_$(arg model) -x $(arg x_pos) -y $(arg y_pos) -z $(arg z_pos) -param robot_description" />
</launch>
```

Assuming that we have chosen the `waffle` model:
```
roscd turtlebot3_description/urdf
pico turtlebot3_waffle.urdf.xacro
```

Notice all of the details that are modeled.  Check out `common_properties.xacro` and `turtlebot3_waffle.gazebo.xacro`, too.

There are also 3D models (`.stl` and `.dae` files) that are used for both the visual and collision components.


### Example 2 - Husky

Now, let's do the same exercise with our Husky.

```
roscd husky_gazebo
cd launch
```

We'll trace the sub-files that are called when we launch a Husky in Gazebo:

- `husky_playpen.launch`
	- `$(find husky_gazebo)/launch/playpen.launch`
	- `$(find husky_gazebo)/launch/spawn_husky.launch`  (here is where we actually spawn the model in Gazebo)
	    - `$(find husky_control)/launch/control.launch` 
	        - Lots of other stuff happening here, numerous nodes launched. 
	        - `$(find husky_description)/launch/description.launch`
                ```
                <launch>
                  <arg name="robot_namespace" default="/"/>
                  <param name="robot_description" command="$(find xacro)/xacro '$(find husky_description)/urdf/husky.urdf.xacro'
                    robot_namespace:=$(arg robot_namespace)" />
                </launch>
                ```
	    - `$(find husky_control)/launch/teleop.launch`
	        - Launches keyboard and joystick nodes.
	    - `$(find husky_gazebo)/launch/realsense.launch`
	        - `<node pkg="pointcloud_to_laserscan" type="pointcloud_to_laserscan_node" name="realsense_to_laserscan" output="screen">`


Now, let's examine the `husky.urdf.xacro` file:
```
roscd husky_description
cd urdf
pico husky.urdf.xacro
```

### Resources
- Textbook Chapter 16
- https://classic.gazebosim.org/tutorials?tut=ros_urdf&cat=connect_ros
- https://wiki.ros.org/urdf/Tutorials
- https://wiki.ros.org/urdf
    - https://wiki.ros.org/xacro
- http://sdformat.org/

### Exercises
1.  Complete the "Learning URDF Step by Step" tutorial found at https://wiki.ros.org/urdf/Tutorials
2.  Create a Gazebo `.sdf` model, given the files found here:  [files/sman.zip](files/sman.zip)
    - Use this model as an example: [files/fire_hydrant.zip](files/fire_hydrant.zip)
3.  Create a Gazebo `.sdf` model from your own `.stl`, `.dae`, or `.obj` creation.

---

## 10 - Adding/Deleting/Moving Models in Gazebo

We will look at some of the ways to add model objects (like dumpsters, cubes, humans) to a Gazebo world.  
- Please see above if you're looking to add one or more **robots**.  

The notes below contain numerous references to material from https://classic.gazebosim.org/tutorials?tut=ros_comm#Tutorial:ROSCommunication.


Let's begin by starting Gazebo with an empty world:
```
roslaunch gazebo_ros empty_world.launch
```

### What is a "model"?
- Take a look at https://classic.gazebosim.org/tutorials?tut=model_structure&cat=build_robot for info on how a "model database" is structured.

    > A model database must abide by a specific directory and file structure. The root of a model database contains one directory for each model, and a database.config file with information about the model database. Each model directory also has a model.config file that contains meta data about the model. A model directory also contains the SDF for the model and any materials, meshes, and plugins.
    > 
    > The structure is as follows (in this example the database has only one model called model_1):
    > 
    > - *Database*
    >     - *database.config* : Meta data about the database. This is now populated automatically from `CMakeLists.txt`
    >     - *model_1* : A directory for `model_1`
    >         - *model.config* : Meta-data about `model_1`
    >         - *model.sdf* : SDF description of the model
    >         - *model.sdf.erb* : Ruby embedded SDF model description
    >         - *meshes* : A directory for all COLLADA and STL files
    >         - *materials* : A directory which should only contain the `textures` and `scripts` subdirectories
    >             - *textures* : A directory for image files (jpg, png, etc).
    >             - *scripts* : A directory for OGRE material scripts
    >         - *plugins* : A directory for plugin source and header files
     
- Lots of models are available at https://github.com/osrf/gazebo_models.  You can even clone the repo if you like.

Let's look at two example models:
- `beer` https://github.com/osrf/gazebo_models/tree/master/beer
- `bus` https://github.com/osrf/gazebo_models/tree/master/bus


### Add a Model
We are looking to add a model to an existing Gazebo world that is already running.  If you already know you want one or more models in your world at launch time, your best option is to simply include those models in your `.world` file.  For example, see:
- `/opt/ros/noetic/share/husky_gazebo/worlds/clearpath_playpen.world`;
- Most of the worlds in `/usr/share/gazebo-11/worlds`.


Note that the paths where Gazebo searches for models are saved in the `GAZEBO_MODEL_PATH` variable.  Try:
```
echo $GAZEBO_MODEL_PATH
````
- If you need to add a path to this variable, the best option is to edit your `~/.bashrc` file.  Mine has the following lines (just as examples...you might not have these particular paths on your system):
    ```
    export GAZEBO_MODEL_PATH=$GAZEBO_MODEL_PATH:~/PX4-Autopilot/Tools/sitl_gazebo/models
    export GAZEBO_MODEL_PATH=$GAZEBO_MODEL_PATH:~/catkin_ws/src/ub_gazebo/models
    ```     

1. **Via Gazebo GUI**.  Click the "Insert" tab on the left side and choose a model.  If you have models saved on your computer but they don't appear in the list, click the "Add Path" button.
    - NOTE:  The models in the `https://fuel.gazebosim.org` seem to work well in Gazebo Classic.
        - However, I'm unable to insert any models from the `https://fuel.ignitionrobitics.org` list within the Gazebo GUI.  Perhaps these can be added manually?

2. **Via `rosrun gazebo_ros spawn_model`**
    - First, let's find a model on your system:
        ```
        ls ~/.gazebo/models
        ```
        - In this example, I found a `beer` directory, which contains a `.sdf` model.

    - Now, we'll add this model to our Gazebo world:
    ```
    rosrun gazebo_ros spawn_model -file ~/.gazebo/models/beer/model.sdf -sdf -model beer_1 -y 0.2 -x -0.3
    ```
    - The model name (in this case, `beer_1`) must be unique.
        
    - To see all of the `spawn_model` options, type `rosrun gazebo_ros spawn_model -h`
    
3. **Via `ub_gazebo` package**
    - See https://github.com/optimatorlab/ub_gazebo?tab=readme-ov-file#adding-objectsmodels-not-robots-to-gazebo


#### Example - Make it Snow
This Python script will produce 100 small white cubes that fall from the sky in Gazebo.  It uses the [`ub_gazebo`](https://github.com/optimatorlab/ub_gazebo) package.

```
import rospy
import model_launcher as ml
import numpy as np

rospy.init_node('myNode', anonymous=True)

# Initialize a dictionary for all of our models/objects
objects = {}


for i in range(0,100):
	# Our "snow" will be tiny white boxes (more like falling ice cubes).
	# ----------------------------------------------------------
	# TODO: Randomize the size and origin location of each box.
	# ----------------------------------------------------------	
	dim = 0.005
	args = { 'color_r': 1.0, 'color_g': 1.0, 'color_b': 1.0,
			 'dim_x': dim, 'dim_y': dim, 'dim_z': dim, 
			 'useGravity': True}

	objects[f'box{i}'] = ml.launcher(objectType = 'box', 
						 gazeboModelName = f'box{i}',
						 namespace = 'snow', 
						 modelYawOffsetRad = 0,					  
						 x = 0, y = 0, z = 14, 
						 rollRad = 0, pitchRad = 0, yawRad = 0, 
						 args=args)	
```



### Get Model State/Position and Properties
1. **Via Gazebo GUI**.
    - Select the model from the "World" tab on the left side of the GUI.  You may need to expand the "Models" list.
    - On the bottom portion of the left-hand panel, expand the "Pose" section, which will reveal the position and orientation.
    
2. **Via `rosservice call gazebo/delete_model`**
    - First, let's see what models we have available:
        ```
        rostopic echo -n 1 /gazebo/model_states
        ```
        > ```
        > name:
        >   - ground_plane
        >   - beer_1
        > ```
        
    - We could also examine the overall Gazebo world properties:
        ```
        rosservice call gazebo/get_world_properties
        ```
        
        This returns
        > ```
        > sim_time: 46.226
        > model_names: 
        >   - ground_plane
        >   - beer_1
        > rendering_enabled: True
        > success: True
        > status_message: "GetWorldProperties: got properties"
        > ```        
        
    - Now, get the "state" of the `beer_1` model:
        ```
        rosservice call gazebo/get_model_state '{model_name: beer_1}'
        ```
        
        This returns
        > ```
        > header: 
        >   seq: 1
        >   stamp: 
        >     secs: 6189
        >     nsecs: 711000000
        >   frame_id: ''
        > pose: 
        >   position: 
        >     x: -0.3000000096127953
        >     y: 0.1999999479047525
        >     z: -2.182911401693577e-06
        >   orientation: 
        >     x: 4.7499127773985604e-07
        >     y: 2.065120920971766e-08
        >     z: -6.72754543001391e-07
        >     w: 0.9999999999996607
        > twist: 
        >   linear: 
        >     x: 0.0
        >     y: 0.0
        >     z: 0.0
        >   angular: 
        >     x: 0.0
        >     y: 0.0
        >     z: 0.0
        > success: True
        > status_message: "GetModelState: got properties"
        > ```

    - Finally, get the "properties" of the `beer_1` model:
        ```
        rosservice call gazebo/get_model_properties '{model_name: beer_1}'
        ```
        
        The beer can is pretty boring:
        > ```
        > parent_model_name: ''
        > canonical_body_name: ''
        > body_names: 
        >   - link
        > geom_names: 
        >   - collision
        > joint_names: []
        > child_model_names: []
        > is_static: False
        > success: True
        > status_message: "GetModelProperties: got properties"
        > ```        
        
3. **Via `ub_gazebo` package**
    - This functionality isn't available yet, but will be simply a matter of implementing the `rosservice` call described above.



### Moving a Model

1. **Via Gazebo GUI**.
    - Enter the "selection mode" by pressing the "Esc" key or clicking the arrow icon at the top of the window.
    - Click on the model you wish to move.
        - Enter "translation mode" by pressing "T" or clicking the crosshairs icon at the top.
        - Enter "rotation model" by pressing "R" or clicking the circular icon at the top.
   
2. **Via `gazebo/set_model_state` service**
    ```
    rosservice call /gazebo/set_model_state '{model_state: { model_name: beer_1, pose: { position: { x: 0, y: 0 ,z: 2 }, orientation: {x: 0, y: 0, z: 0, w: 0 } }, twist: { linear: {x: 0.0 , y: 0 ,z: 0 } , angular: { x: 0.0 , y: 0 , z: 0.0 } } , reference_frame: world } }'
    ```

3. **Via `gazebo/set_model_state` topic**
    This has the advantage of working more quickly, as it doesn't need to wait for a response from the service. 

    ```
    rostopic pub -r 20 /gazebo/set_model_state gazebo_msgs/ModelState '{model_name: beer_1, pose: { position: { x: 1, y: 1, z: 2 }, orientation: {x: 0, y: 0, z: 0, w: 0 } }, twist: { linear: { x: 0, y: 0, z: 0 }, angular: { x: 0, y: 0, z: 0}  }, reference_frame: world }' 
    ```
    
    Here, `-r 20` sets the publication rate at 20 Hz.  Note what happens to the beer can when you stop publishing.


4. **Via `ub_gazebo` package**
    - This functionality isn't available yet, but will be a matter of publishing to the `/gazebo/set_model_state` topic described above.

5. You can also set trajectories for your model to follow when spawning from a `.world` file.  See `/usr/share/gazebo-11/worlds/actor.world`:
    ```
         <actor name="actor">
             <skin>
                <filename>file://media/models/walk.dae</filename>
                <scale>1.0</scale>
             </skin>
             <pose>0 0 0 0 0 0</pose>
             <animation name="walking">
                <filename>file://media/models/walk.dae</filename>
                <scale>1.000000</scale>
                <interpolate_x>true</interpolate_x>
             </animation>
             <script>
                <loop>true</loop>
                <delay_start>0.000000</delay_start>
                <auto_start>true</auto_start>
                <trajectory id="0" type="walking">
                   <waypoint>
                      <time>0.000000</time>
                      <pose>0.000000 1.000000 0.000000 0.000000 0.000000 0.000000</pose>
                   </waypoint>
                   <waypoint>
                      <time>0.500000</time>
                      <pose>0.195090 0.980785 0.000000 0.000000 0.000000 -0.196350</pose>
                   </waypoint>
                   <waypoint>
                      <time>1.000000</time>
                      <pose>0.382683 0.923880 0.000000 0.000000 0.000000 -0.392699</pose>
                   </waypoint>
                </trajectory>
             </script>
          </actor>
    ```


### Deleting a Model
1. **Via Gazebo GUI**.
    - Select the model from the "World" tab on the left side of the GUI.  You may need to expand the "Models" list.
    - Right click on the name of the model you wish to delete and choose "Delete".

2. **Via `gazebo/spawn_sdf_model` service**
    We'll say goodbye to our `beer_1` model:
    ```
    rosservice call gazebo/delete_model '{model_name: beer_1}'
    ```
    
3. **Via `ub_gazebo` package**
    - See https://github.com/optimatorlab/ub_gazebo?tab=readme-ov-file#adding-objectsmodels-not-robots-to-gazebo


### Resources
- https://classic.gazebosim.org/tutorials?tut=ros_comm#Tutorial:ROSCommunication
- https://answers.gazebosim.org//question/5553/how-does-one-use-gazebospawn_sdf_model/
- https://classic.gazebosim.org/tutorials?tut=ros_comm
- https://answers.ros.org/question/375645/using-modelstates-and-twist-to-move-model/
- https://classic.gazebosim.org/tutorials?tut=ros_comm#Services:Stateandpropertygetters
- https://answers.ros.org/question/9783/programmatically-get-modelstate-from-gazebo/
- https://answers.ros.org/question/261782/how-to-use-getmodelstate-service-from-gazebo-in-python/
- https://gazebosim.org/api/gazebo/3.7/migrationsdf.html


### Exercises
1.  Add a model from within the Gazebo GUI.
2.  Add a model using `rosrun gazebo_ros spawn_model`.   Rotate the model by 45 degrees about the z axis (yaw), and by 90 degrees about the x axis (roll)
3.  Add some "snow" to gazebo, then spawn a Husky in the world.  Drive the Husky through the "snow".  
    - List all of the ways that you can make the Husky move. 
  

--- 

## 11 - `roslibjs` (ROS + JavaScript/HTML)
`roslibjs` is the ROS JavaScript library.  It allows webpages to communicate with ROS.  For example, the webpage can 
- subscribe to topics, and publish messages;
- call a service (I don't believe that hosting the service is supported)

Example code is available on the `roslibjs` wiki (https://wiki.ros.org/roslibjs) and on the `roslibjs` GitHub site (https://github.com/RobotWebTools/roslibjs/tree/develop/examples).

The [`ub_web`](https://github.com/optimatorlab/ub_web) package makes use of `roslibjs` to provide web-based monitoring and control of robots. 

Visit https://github.com/optimatorlab/ub_web to get started.

![image](https://github.com/optimatorlab/ub_web/assets/18486796/2fc5222f-4ca8-4c0c-aaad-3043c5e6d339)


### Resources
- https://wiki.ros.org/roslibjs
- https://github.com/RobotWebTools/roslibjs/tree/develop/examples
- https://github.com/optimatorlab/ub_web

### Exercises
1.  Read thru the tutorials at https://wiki.ros.org/roslibjs
2.  Complete the "Basic ROS Functionality" tutorial (https://wiki.ros.org/roslibjs/Tutorials/BasicRosFunctionality)
3.  (in-class) Try to get this one to work: https://wiki.ros.org/roslibjs/Tutorials/Publishing%20video%20and%20IMU%20data%20with%20roslibjs

--- 

## 12 - Other robots

- Spot
    - See https://github.com/chvmp/champ
    - See https://taras-borovets.medium.com/simulation-tools-for-boston-dynamics-spot-28a10d88e325

Iris? Clover?  PX4-based.
- https://dev.px4.io/v1.11_noredirect/en/simulation/ros_interface.html
- https://github.com/CopterExpress/clover/tree/master/clover

Robot arm
- ur5
    - https://sir.upc.edu/projects/rostutorials/final_work/index.html
    - https://app.gazebosim.org/anni/fuel/models/ur5_rg2.  Does this work?

- MoveIt!
    - https://ros-planning.github.io/moveit_tutorials/doc/getting_started/getting_started.html

NASA JPL Open Source Rover Project
- https://github.com/nasa-jpl/open-source-rover

DiffBot 2-wheeled differential drive robot 
- https://github.com/ros-mobile-robots/diffbot

Ubiquity Robotics "Magni" cart
- https://learn.ubiquityrobotics.com/noetic_quick_start_ros101

### Exercises
1. (in class) Install Gazebo simulation packages for these robots.

---

## 13 - Autonomous Navigation
TODO

### Nav Stack
Husky
- Move Base:  https://www.clearpathrobotics.com/assets/guides/noetic/husky/HuskyMove.html
- AMCL: https://www.clearpathrobotics.com/assets/guides/noetic/husky/HuskyAMCL.html
- Gmapping: https://www.clearpathrobotics.com/assets/guides/noetic/husky/HuskyGmapping.html

- http://wiki.ros.org/move_base
- http://wiki.ros.org/amcl
- http://wiki.ros.org/gmapping 
- http://wiki.ros.org/navigation
- http://wiki.ros.org/navigation/Tutorials **CHECK THIS OUT**


### SLAM

See diffbot 
- https://github.com/ros-mobile-robots/diffbot
- https://github.com/ros-mobile-robots/diffbot/tree/noetic-devel

http://www.ros.org/wiki/slam_gmapping
http://wiki.ros.org/hector_slam

### Move_Base
https://answers.ros.org/question/390968/sending-goals-to-the-navigation-stack-help/?answer=390972
https://www.google.com/search?q=ros+actionlib+python+move+base+goal&client=ubuntu-chr&hs=ruz&sca_esv=589713028&ei=uLx2ZaTRNoPaptQPg66fuAQ&oq=ros+actionlib+python+mov&gs_lp=Egxnd3Mtd2l6LXNlcnAiGHJvcyBhY3Rpb25saWIgcHl0aG9uIG1vdioCCAUyBRAhGKABMgUQIRigATIFECEYoAEyBRAhGKABMggQIRgWGB4YHTIIECEYFhgeGB0yCBAhGBYYHhgdMggQIRgWGB4YHUiTQFDrA1iIFnABeAGQAQCYAWagAcgCqgEDMy4xuAEDyAEA-AEBwgIKEAAYRxjWBBiwA8ICBhAAGBYYHsICCxAAGIAEGIoFGIYDwgIFECEYqwLiAwQYACBBiAYBkAYI&sclient=gws-wiz-serp
https://answers.ros.org/question/252220/sending-goals-to-the-navigation-stack/
https://get-help.robotigniteacademy.com/t/naviagation-goal-through-command-terminal/20519/2
https://learn.ubiquityrobotics.com/python_script_1

```
*******************************
See `robot_localization`.
Look at emails I sent to myself on Jan 8/9
*******************************
```

### Exercises
1. How to specify goal in Python?

---

## 14 - Sensors and Other Input Sources
TODO 

- Sonar
- IMU
- GPS
- Stereo Cameras (Fernandez p. 202)
- RealSense
- Wii peripherals

### Exercises
1. Time of Flight sensor
    - Let's use `rqt_multiplot` to view our VL53L1X data.  Maybe partitioned into zones?
    - Given a topic name and data type, what ways can you think of to view this data?  matplotlib?
    - http://wiki.ros.org/Drivers/Tutorials/DistanceMeasurementWithToFSensorVL53L1XPython
2. Avoid obstacles using RealSense
3. Control robots with Wii peripherals


---

## 15 - More fun with Computer Vision
TODO 

- Finish line following exercise (and implement on Husky)

- AR Toolkit, Object Recognition, Visual Odometry (Fernandez p. 214)

- https://docs.opencv.org/4.x/d7/d53/tutorial_py_pose.html
    - Pose Estimation
    - Draw 3D objects on an image

- Computer vision hand movement?
    - https://pyimagesearch.com/2015/05/25/basic-motion-detection-and-tracking-with-python-and-opencv/ 
	
- ArUco tags
    - See https://docs.ros.org/en/noetic/api/visualization_msgs/html/msg/Marker.html 
    - https://wiki.ros.org/fiducials
    - Localize drone/rover from known tag locations
	    
- barcodes

- How to do stereo vision?  Can we get depth?
    - See Fernandez, p. 202

### Exercises
1.  TBD

--- 

## 16 - Implement things on Real Hardware
TODO

- Field trip to SOAR
- Map 4th floor with Husky
- Play around with SDR?

### Exercises
1.  TBD

--- 

## 17 - ROS/Gazebo Cheat Sheets

- Spend one class working on the ultimate ROS/Gazebo cheat sheet
    - Identify any topics we missed.
    
### Some things to include (before I forget):
**ROS**
Super useful visual tool for viewing topics:
```
rqt -s rqt_msg
```

**Gazebo**
```
gazebo worlds/stacks.world
gzserver worlds/stacks.world / gzclient
```

List standard worlds:
```
ls /usr/share/gazebo-11/worlds/
ls /opt/ros/noetic/share/husky_gazebo/worlds/
```

Paths where worlds might be:
```
echo $GAZEBO_RESOURCE_PATH    
```
