# Class Notes
We'll add to this document as we progress through the semester.

---

## 1 - Viewing a simulated "Husky" robot
- See https://www.clearpathrobotics.com/assets/guides/noetic/husky/InterfacingWithHusky.html#visualization

### Start Husky Gazebo simulation:	
In Terminal 1:
```
roslaunch husky_gazebo husky_playpen.launch
```
- You can also try `roslaunch husky_gazebo empty_world.launch`, but it's pretty boring.

In Terminal 2:
```
roslaunch husky_viz view_robot.launch 
```

#### Notes:
- By default, the Husky does not publish scan or camera data.
- Take a look at `/opt/ros/noetic/share/husky_description/urdf/husky.urdf.xacro` (DO. NOT. EDIT. THIS. FILE.)
    ```
    pico /opt/ros/noetic/share/husky_description/urdf/husky.urdf.xacro 
    ```
    - `ctrl` + `x` to exit
      
- To get front/rear scanners and an RGBD camera, make sure the following environment variables are set in `~/.bashrc`:	
    ```
    export HUSKY_LMS1XX_ENABLED=1
    export HUSKY_LMS1XX_SECONDARY_ENABLED=1
    export HUSKY_REALSENSE_ENABLED=1
    export HUSKY_REALSENSE_XYZ="0.31 0 0"
    ```

    ```
    pico ~/.bashrc
    ```
    - `ctrl` + `o` to save/output
    - `ctrl` + `x` to exit

### View data in RViz	
- camera
- scan
- odom
	
The data we're visualizing here is actually being "published" by our simulated robot. 

### List topics	
```
rostopic list
```
- camera, scan, GPS, 
	
With ROS, it is possible to observe the stream of raw data directly from the terminal.
```
# Echo topic data	
rostopic echo /front/scan
```

ROS "Topics" use a publish/subscribe model/paradigm.
- publish vs subscribe	The Husky posts some data, it listens for some data
    - See `/cmd_vel`
	
ROS "Nodes"
We can visualize ROS info with `rqt`:
```
rqt
```
- plugins -> node graph


    
### Summary
What did we just see?
- Gazebo is a physics-based simulation engine
- RViz makes it easy to view the data being generated by the robot (either a real robot or a simulated robot)
- Our robot publishes data, and it also listens for data


### Before Next Class
- ~~Read~~ Study textbook Chapter 1
- Scroll through the ROS tutorials website:  http://wiki.ros.org/ROS/Tutorials
    - You don't have to do any of the tutorials yet, just take a look at the materials.

---

## 2 - Make our Husky Move
Let's see all of the topics currently being published:
```
rostopic list
```

Our Husky listens to (or, is "subscribed" to) the `cmd_vel` topic.  Let's get some information on that topic:
```
rostopic info cmd_vel
```

This produces:
```
Type: geometry_msgs/Twist
 
Publishers: None
   
Subscribers: 
* /twist_mux (http://192.168.0.209:36683/)
```

The topic "type" specifies the structure of the information being passed between "nodes".  To view the structure of the `geometry_msgs/Twist` topic type:
```
rosmsg show geometry_msgs/Twist
```

This produces:
```
geometry_msgs/Vector3 linear
  float64 x
  float64 y
  float64 z
geometry_msgs/Vector3 angular
  float64 x
  float64 y
  float64 z
```

We can publish topics directly from the terminal (command line).  
The general form is:
    - `rostopic pub /the_topic_name the_topic_type [args]`
For the Husky `cmd_vel` topic, the specific command is:    
    - `rostopic pub -r 10 /cmd_vel geometry_msgs/Twist  '{linear:  {x: 0.1, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}'`    
    
This isn't a great way to control our robot.

Let's look at some better ways.  In each of the following approaches, we're going to have some code running in the background to capture commands and send them to the robot.
This "code running in the background" is called a "node".  
A "node" is typically written in either C++ or Python.  In this class, we use Python exclusively.
- So, you can think of a node as being just a Python script that interacts with ROS.

Here's Python code for a node that publishes Twist commands randomly, every x seconds:
```
#!/usr/bin/env python3

import random
import rospy
from geometry_msgs.msg import Twist


class Publisher():
	def __init__(self):
	
		rospy.init_node("cmd_vel_publisher")

		self.cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=1)
		self.twist = Twist()

		self.rate = rospy.Rate(1/5)	# [Hz]

		self.run()
		
	def createTwistMsg(self):
		msg = Twist()
		msg.linear.x  = random.random()*5
		msg.angular.z = random.random()*5
		return msg
		
	def run(self):
		count = 0
		while count < 10:

			cmd = self.createTwistMsg()
      print(cmd)
			self.cmd_vel_pub.publish(cmd)
			
			count += 1
			
			self.rate.sleep()
			
			
if __name__ == "__main__":
	Publisher()
```

### Before Next Class
- ~~Read~~ Study textbook Chapter 2
- Continue to scroll through the ROS tutorials website:  http://wiki.ros.org/ROS/Tutorials
    - You don't have to do any of the tutorials yet, just take a look at the materials.
- Create a 1-page Linux "cheat sheet".
    - You are strongly encouraged to find good examples online (be sure to give credit to those that inspire you)
    - Please don't include ROS commands on your sheet.  We'll have a separate ROS cheat sheet later.
    - Take a look in your previous commands to see some of those we've used this semester.  `pico ~/.bash_history`.
 

---

## 3 - Networking

- Make sure your VM is setup for "bridged" network adapter.
- Connect to the class Wi-Fi network, with password `ros4ever!`, from your **host** computer (not from your Ubuntu VM).
- One computer in the network needs to be running `roscore`.  This computer is known as the "ROS master".  You will need to know its IP address.
    - Once you know the IP address of the "ROS master", issue the following command in a Ubuntu terminal:
        ```
        export ROS_MASTER_URI="http://192.168.0.xxx:11311"
        ```
        - Replace `xxx` as appropriate

    - To find **your** computer's IP address, issue this command from an Ubuntu terminal:  `ifconfig`.
- Type `rostopic list` to see if you are connected

---

## 4 - Teleoperation

"Teleoperation" refers to remote control of a vehicle/robot.  We will explore several different teleop approaches:
- Keyboard control
- Joystick control
- Custom Web (HTML/JavaScript) interface

#### Keyboard Control
We will make use of the existing `teleop_twist_keyboard` package.
- See https://github.com/ros-teleop/teleop_twist_keyboard for documentation
- If you don't already have a robot running, you can start one like this:
    ```
    roslaunch husky_gazebo empty_world.launch
    ```

To use the default settings, open a new terminal window and type:
```
rosrun teleop_twist_keyboard teleop_twist_keyboard.py
``` 

Better yet, pass some custom parameter values, like this:
```
rosrun teleop_twist_keyboard teleop_twist_keyboard.py _repeat_rate:=10.0 _key_timeout:=0.6 cmd_vel:=my_cmd_vel _speed:=0.9 _turn:=0.8
```
This will set the following parameter values:
- `repeat_rate`: How fast, in Hz, that the last command is repeated.  Default is `0.0` (no repeat)
- `key_timeout`: How long, in seconds, that the system will wait for another keypress before giving up.
    - From the documentation:  "It is recommended that you set `key_timeout` higher than the initial key repeat delay on your system (This delay is 0.5 seconds by default on Ubuntu, but can be adjusted)."
- `cmd_vel`:  Name of topic to be published.  Default is `cmd_vel`.
    - NOTE:  I don't see how this actually has an impact, but it appears to work as advertised.  See https://github.com/ros-teleop/teleop_twist_keyboard/blob/master/teleop_twist_keyboard.py 
- `speed` and `turn`:  Values for `linear.x` and `angular.z`, respectively. 

Why are there things after the name of the Python script that start with an underscore and include the "walrus operator" (`:=`)?
This actually lets us set variables in the Python script, using `rospy.get_param("~<parametername>", <defaultvalue>)`.
Let's take a look at the `teleop_twist_keyboard.py` script (see https://github.com/ros-teleop/teleop_twist_keyboard/blob/master/teleop_twist_keyboard.py).
You'll see the following:
```
speed = rospy.get_param("~speed", 0.5)
turn = rospy.get_param("~turn", 1.0)
speed_limit = rospy.get_param("~speed_limit", 1000)
turn_limit = rospy.get_param("~turn_limit", 1000)
repeat = rospy.get_param("~repeat_rate", 0.0)
key_timeout = rospy.get_param("~key_timeout", 0.5)
```
In the command line, the parameter starts with a `_`; in the Python script, replace the leading `_` with a `~`.


#### Joystick Control
We will explore the following together in class:
- https://wiki.ros.org/teleop_twist_joy
- https://wiki.ros.org/joy
- https://docs.ros.org/en/api/joy/html/

These require a physical joystick (like a PlayStation or XBox controller).

- (placeholder here to document where the `joy` node is saved, how Husky starts it, and how you might start it for other projects.)

#### Custom Controller
- (placeholder here for example code)


## 5 - Autonomous Navigation

We will start by controlling our Husky, but these navigation tools are more broadly applicable.

- Move Base:  https://www.clearpathrobotics.com/assets/guides/noetic/husky/HuskyMove.html
    - http://wiki.ros.org/move_base

- AMCL: https://www.clearpathrobotics.com/assets/guides/noetic/husky/HuskyAMCL.html
    - http://wiki.ros.org/amcl

- Gmapping: https://www.clearpathrobotics.com/assets/guides/noetic/husky/HuskyGmapping.html
    - http://wiki.ros.org/gmapping 

### Further Reading:
- http://wiki.ros.org/navigation
- http://wiki.ros.org/navigation/Tutorials **CHECK THIS OUT**


--- 
