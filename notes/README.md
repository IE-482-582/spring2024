# Class Notes
We'll add to this document as we progress through the semester.

---

## 1 - Viewing a simulated "Husky" robot
- See https://www.clearpathrobotics.com/assets/guides/noetic/husky/InterfacingWithHusky.html#visualization

### Start Husky Gazebo simulation:	
In Terminal 1:
```
roslaunch husky_gazebo husky_playpen.launch
```
- You can also try `roslaunch husky_gazebo empty_world.launch`, but it's pretty boring.

In Terminal 2:
```
roslaunch husky_viz view_robot.launch 
```

#### Notes:
- By default, the Husky does not publish scan or camera data.
- Take a look at `/opt/ros/noetic/share/husky_description/urdf/husky.urdf.xacro` (DO. NOT. EDIT. THIS. FILE.)
    ```
    pico /opt/ros/noetic/share/husky_description/urdf/husky.urdf.xacro 
    ```
    - `ctrl` + `x` to exit
      
- To get front/rear scanners and an RGBD camera, make sure the following environment variables are set in `~/.bashrc`:	
    ```
    export HUSKY_LMS1XX_ENABLED=1
    export HUSKY_LMS1XX_SECONDARY_ENABLED=1
    export HUSKY_REALSENSE_ENABLED=1
    export HUSKY_REALSENSE_XYZ="0.31 0 0"
    ```

    ```
    pico ~/.bashrc
    ```
    - `ctrl` + `o` to save/output
    - `ctrl` + `x` to exit

### View data in RViz	
- camera
- scan
- odom
	
The data we're visualizing here is actually being "published" by our simulated robot. 

### List topics	
```
rostopic list
```
- camera, scan, GPS, 
	
With ROS, it is possible to observe the stream of raw data directly from the terminal.
```
# Echo topic data	
rostopic echo /front/scan
```

ROS "Topics" use a publish/subscribe model/paradigm.
- publish vs subscribe	The Husky posts some data, it listens for some data
    - See `/cmd_vel`
	
ROS "Nodes"
We can visualize ROS info with `rqt`:
```
rqt
```
- plugins -> node graph


    
### Summary
What did we just see?
- Gazebo is a physics-based simulation engine
- RViz makes it easy to view the data being generated by the robot (either a real robot or a simulated robot)
- Our robot publishes data, and it also listens for data


### Before Next Class
- ~~Read~~ Study textbook Chapter 1
- Scroll through the ROS tutorials website:  http://wiki.ros.org/ROS/Tutorials
    - You don't have to do any of the tutorials yet, just take a look at the materials.

---

## 2 - Make our Husky Move
Let's see all of the topics currently being published:
```
rostopic list
```

Our Husky listens to (or, is "subscribed" to) the `cmd_vel` topic.  Let's get some information on that topic:
```
rostopic info cmd_vel
```

This produces:
```
Type: geometry_msgs/Twist
 
Publishers: None
   
Subscribers: 
* /twist_mux (http://192.168.0.209:36683/)
```

The topic "type" specifies the structure of the information being passed between "nodes".  To view the structure of the `geometry_msgs/Twist` topic type:
```
rosmsg show geometry_msgs/Twist
```

This produces:
```
geometry_msgs/Vector3 linear
  float64 x
  float64 y
  float64 z
geometry_msgs/Vector3 angular
  float64 x
  float64 y
  float64 z
```

We can publish topics directly from the terminal (command line).  
The general form is:
    - `rostopic pub /the_topic_name the_topic_type [args]`
For the Husky `cmd_vel` topic, the specific command is:    
    - `rostopic pub -r 10 /cmd_vel geometry_msgs/Twist  '{linear:  {x: 0.1, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}'`    
    
This isn't a great way to control our robot.

Let's look at some better ways.  In each of the following approaches, we're going to have some code running in the background to capture commands and send them to the robot.
This "code running in the background" is called a "node".  
A "node" is typically written in either C++ or Python.  In this class, we use Python exclusively.
- So, you can think of a node as being just a Python script that interacts with ROS.

Here's Python code for a node that publishes Twist commands randomly, every x seconds:
```
#!/usr/bin/env python3

import random
import rospy
from geometry_msgs.msg import Twist


class Publisher():
	def __init__(self):
	
		rospy.init_node("cmd_vel_publisher")

		self.cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=1)
		self.twist = Twist()

		self.rate = rospy.Rate(1/5)	# [Hz]

		self.run()
		
	def createTwistMsg(self):
		msg = Twist()
		msg.linear.x  = random.random()*5
		msg.angular.z = random.random()*5
		return msg
		
	def run(self):
		count = 0
		while count < 10:

			cmd = self.createTwistMsg()
      print(cmd)
			self.cmd_vel_pub.publish(cmd)
			
			count += 1
			
			self.rate.sleep()
			
			
if __name__ == "__main__":
	Publisher()
```

### Before Next Class
- ~~Read~~ Study textbook Chapter 2
- Continue to scroll through the ROS tutorials website:  http://wiki.ros.org/ROS/Tutorials
    - You don't have to do any of the tutorials yet, just take a look at the materials.
- Create a 1-page Linux "cheat sheet".
    - You are strongly encouraged to find good examples online (be sure to give credit to those that inspire you)
    - Please don't include ROS commands on your sheet.  We'll have a separate ROS cheat sheet later.
    - Take a look in your previous commands to see some of those we've used this semester.  `pico ~/.bash_history`.
 

---

## 3 - Networking

- Make sure your VM is setup for "bridged" network adapter.
- Connect to the class Wi-Fi network, with password `ros4ever!`, from your **host** computer (not from your Ubuntu VM).
- One computer in the network needs to be running `roscore`.  This computer is known as the "ROS master".  You will need to know its IP address.
    - Once you know the IP address of the "ROS master", issue the following command in a Ubuntu terminal:
        ```
        export ROS_MASTER_URI="http://192.168.0.xxx:11311"
        ```
        - Replace `xxx` as appropriate

    - To find **your** computer's IP address, issue this command from an Ubuntu terminal:  `ifconfig`.
- Type `rostopic list` to see if you are connected

---

## 4 - Teleoperation

"Teleoperation" refers to remote control of a vehicle/robot.  We will explore several different teleop approaches:
- Keyboard control
- Joystick control
- Custom Web (HTML/JavaScript) interface

#### Keyboard Control
We will make use of the existing `teleop_twist_keyboard` package.
- See https://github.com/ros-teleop/teleop_twist_keyboard for documentation
- If you don't already have a robot running, you can start one like this:
    ```
    roslaunch husky_gazebo empty_world.launch
    ```

To use the default settings, open a new terminal window and type:
```
rosrun teleop_twist_keyboard teleop_twist_keyboard.py
``` 

Better yet, pass some custom parameter values, like this:
```
rosrun teleop_twist_keyboard teleop_twist_keyboard.py _repeat_rate:=10.0 _key_timeout:=0.6 cmd_vel:=my_cmd_vel _speed:=0.9 _turn:=0.8
```
This will set the following parameter values:
- `repeat_rate`: How fast, in Hz, that the last command is repeated.  Default is `0.0` (no repeat)
- `key_timeout`: How long, in seconds, that the system will wait for another keypress before giving up.
    - From the documentation:  "It is recommended that you set `key_timeout` higher than the initial key repeat delay on your system (This delay is 0.5 seconds by default on Ubuntu, but can be adjusted)."
- `cmd_vel`:  Name of topic to be published.  Default is `cmd_vel`.
    - NOTE:  I don't see how this actually has an impact, but it appears to work as advertised.  See https://github.com/ros-teleop/teleop_twist_keyboard/blob/master/teleop_twist_keyboard.py 
- `speed` and `turn`:  Values for `linear.x` and `angular.z`, respectively. 

Why are there things after the name of the Python script that start with an underscore and include the "walrus operator" (`:=`)?
This actually lets us set variables in the Python script, using `rospy.get_param("~<parametername>", <defaultvalue>)`.
Let's take a look at the `teleop_twist_keyboard.py` script (see https://github.com/ros-teleop/teleop_twist_keyboard/blob/master/teleop_twist_keyboard.py).
You'll see the following:
```
speed = rospy.get_param("~speed", 0.5)
turn = rospy.get_param("~turn", 1.0)
speed_limit = rospy.get_param("~speed_limit", 1000)
turn_limit = rospy.get_param("~turn_limit", 1000)
repeat = rospy.get_param("~repeat_rate", 0.0)
key_timeout = rospy.get_param("~key_timeout", 0.5)
```
In the command line, the parameter starts with a `_`; in the Python script, replace the leading `_` with a `~`.


#### Joystick Control
We will explore the following together in class:
- https://wiki.ros.org/teleop_twist_joy
- https://wiki.ros.org/joy
- https://docs.ros.org/en/api/joy/html/

These require a physical joystick (like a PlayStation or XBox controller).

- (placeholder here to document where the `joy` node is saved, how Husky starts it, and how you might start it for other projects.)

#### Custom Controller
- (placeholder here for example code)


## 5 - Autonomous Navigation

We will start by controlling our Husky, but these navigation tools are more broadly applicable.

- Move Base:  https://www.clearpathrobotics.com/assets/guides/noetic/husky/HuskyMove.html
    - http://wiki.ros.org/move_base

- AMCL: https://www.clearpathrobotics.com/assets/guides/noetic/husky/HuskyAMCL.html
    - http://wiki.ros.org/amcl

- Gmapping: https://www.clearpathrobotics.com/assets/guides/noetic/husky/HuskyGmapping.html
    - http://wiki.ros.org/gmapping 

### Further Reading:
- http://wiki.ros.org/navigation
- http://wiki.ros.org/navigation/Tutorials **CHECK THIS OUT**


--- 


## 6 - Building a ROS Package
In this lesson we will build our own ROS package.  

Why do we need to create a package?  Why not just run our Python scripts from some random directory?
1. Packages are a nice way to organize your code, especially if you're working on a project.
2. If you want to create customized topics or services, you'll need to create a package.

To get a better understanding of how to build a package, we're going to create a project for a collection of turtlebots, each with a unique ID.  The turtlebots will be looking for aruco tags.  When they find one, they will report the tag ID and the location of the tag.  The message will carry this information:
- The ID of each turtlebot.  We'll call this `robotID`.  It will be an integer.
- The ID of each discovered aruco tag.  Each tag has an integer ID.  There might be several tags discovered at once.
- The location of each aruco tag (`x`, `y`, and `z` floating point coordinates).

There is not an existing ROS message definition that has these fields.

Let's build our package, which we'll call `turtletag`.  

### 1.  Create the Package
```
cd ~/catkin_ws/src
catkin_create_pkg turtletag
```

- This will create the `~/catkin_ws/src/turtletag` directory, which will be pre-populated with 2 files:  `CMakeLists.txt` and `package.xml`
    - We'll come back to these files shortly.
    

### 2.  Structure/Organize the Package
We'll create some directories to help keep our code organized:
```
cd ~/catkin_ws/src/turtletag
mkdir scripts    # Where our Python code (nodes) will go
mkdir msg        # Where we'll save our custom message definitions
mkdir launch     # Where we'll save .launch files
```
- If we had custom services, we'd also run `mkdir srv`.
    
### 3.  Create our Custom Message Definition

We will name our tag-locating message `tagloc.msg`.  It will be saved as `~/catkin_ws/src/turtletag/msg/tagloc.msg`.  Let's open a text editor to create the message:
```
cd ~/catkin_ws/src/turtletag/msg
pico tagloc.msg
```

In the text editor, write the following:
```
int32 robotID
int32 tagID
geometry_msgs/Point position
```

- See https://docs.ros.org/en/noetic/api/geometry_msgs/html/msg/Point.html.  You can find `Point.msg` if you run `roscd geometry_msgs/msg`.
- `geometry_msgs/Point` has this structure:
    ```
    # This contains the position of a point in free space
    float64 x
    float64 y
    float64 z
    ```

### 4. Finish Configuring our Package
There are two files that we need to edit:
#### `package.xml`
Run `pico ~/catkin_ws/src/turtletag/package.xml`

Scroll down to where you see the `<buildtool_depend>catkin</buildtool_depend>` line.  Paste the following after that line:

```
  <depend>roscpp</depend>
  <depend>rospy</depend>
  <depend>std_msgs</depend>
  <depend>geometry_msgs</depend>

  <build_export_depend>message_generation</build_export_depend>
  <exec_depend>message_runtime</exec_depend>
```


#### `CMakeLists.txt`
You'll need to follow these instructions **very carefully**.  There are many sections of the file that look quite similar.  Make sure things match **exactly**.

1.  Find the line that reads `find_package(catkin REQUIRED)`  (**exactly like this**), and replace it as follows:
    ```
    find_package(catkin REQUIRED COMPONENTS
      roscpp
      rospy
      std_msgs
      geometry_msgs
      message_generation
    )
    ```
    
2.  Find the block that reads **exactly** as:
    ```
    # add_message_files(
    #   FILES
    #   Message1.msg
    #   Message2.msg
    # )
    ```

    Replace this block with:

    ```
    add_message_files(
      FILES
      tagloc.msg
    )
    ```
    
3.  Find the block that reads **exactly** as:
    ```
    # generate_messages(
    #   DEPENDENCIES
    #   std_msgs  # Or other packages containing msgs
    # )
    ```

    Replace this block with:

    ```
    generate_messages(
      DEPENDENCIES
      std_msgs
      geometry_msgs
    )
    ```        
    
4.  Find the block that reads **exactly** as:   
    ```
    catkin_package(
    #  INCLUDE_DIRS include
    #  LIBRARIES turtletag
    #  CATKIN_DEPENDS other_catkin_pkg
    #  DEPENDS system_lib
    )
    ```

    Replace this block with:

    ```
    catkin_package(
    #  INCLUDE_DIRS include
    #  LIBRARIES gcs
       CATKIN_DEPENDS roscpp rospy std_msgs geometry_msgs message_runtime
    #  DEPENDS system_lib
    )
    ```
    
5.  Find the block that reads **exactly** as:   
    ```
    include_directories(
    # include
    # ${catkin_INCLUDE_DIRS}
    )
    ```

    Replace this block with:

    ```
    include_directories(
      ${catkin_INCLUDE_DIRS}
    )    
    ```    

Save the file.


### 5. Recompile (make) our Package
Now we need to compile the package so ROS knows about our custom message definition (and all the other things our package depends on):
```
cd ~/catkin_ws
catkin_make
```



### 6.  Testing
Let's see if we can now generate a `tagloc` message in Python.

First, open a Python terminal:
```
python3
```

Now, type the following:
```
from turtletag.msg import tagloc

myMsg = tagloc()

myMsg
```

You should see
> ```
> robotID: 0
> tagID: 0
> position: 
>   x: 0.0
>   y: 0.0
>   z: 0.0
> ```


**Summary**:  We covered the steps for creating a ROS package, which was motivated by our need for a message type that doesn't natively exist in ROS.


### Further Reading
- https://wiki.ros.org/ROS/Tutorials/CreatingPackage
    - https://wiki.ros.org/catkin/CMakeLists.txt
- https://wiki.ros.org/ROS/Tutorials/BuildingPackages
- See Chapter 3
- https://wiki.ros.org/msg

--

## 7 - An intro to launch files

"Launch Files" provide an organized way of starting `roscore`, Gazebo, and multiple nodes simultaneously.  They provide a nice alternative to the process of opening a separate terminal window for each ROS-related command.

Here's an example where we use a launch file to
- Start a Gazebo world;
- Spawn 2 turtlebot robots; and
- Start a Python node.

Save the following as `~/catkin_ws/src/turtletag/launch/demo.launch`:

```
<?xml version="1.0"?>
<launch>
  <arg name="gui" default="true" doc="Show GUI? [true, false]"/>
  <arg name="headless" default="false" doc="Headless? [true, false]"/>  <!-- I don't think this actually does anything -->

  <include file="$(find gazebo_ros)/launch/empty_world.launch">
	<arg name="world_name" value="$(find turtlebot3_gazebo)/worlds/turtlebot3_autorace.world"/>
				  	
    <arg name="paused" value="false"/>
    <arg name="use_sim_time" value="true"/>
    <arg name="gui" value="$(arg gui)"/>
    <arg name="headless" value="$(arg headless)"/>
    <arg name="debug" value="false"/>
  </include>
  
  <arg name="first_tb3"       default="tb3_1"/>  <!-- Each name must be unique -->
  <arg name="first_tb3_model" default="$(env TURTLEBOT3_MODEL)" doc="model type [burger, waffle, waffle_pi]"/>
  <arg name="first_tb3_x"     default=" 0.656"/>
  <arg name="first_tb3_y"     default=" 1.572"/>
  <arg name="first_tb3_z"     default=" 0.0"/>
  <arg name="first_tb3_yaw"   default="-1.57"/>
  <arg name="first_tb3_cam"   default="$(arg first_tb3)/camera/rgb/image_raw"/>

  <arg name="second_tb3"       default="tb3_2"/>  <!-- Each name must be unique -->
  <arg name="second_tb3_model" value="burger"/>   <!-- Here we'll just hard-code the model type -->  
  <arg name="second_tb3_x"     default=" 1.159"/>
  <arg name="second_tb3_y"     default=" 1.524"/>
  <arg name="second_tb3_z"     default=" 0.0"/>
  <arg name="second_tb3_yaw"   default="-1.57"/>
  <arg name="second_tb3_cam"   default="$(arg second_tb3)/camera/rgb/image_raw"/>
  
  
  <group ns = "$(arg first_tb3)">
    <param name="robot_description" 
     command="$(find xacro)/xacro $(find turtlebot3_description)/urdf/turtlebot3_$(arg first_tb3_model).urdf.xacro" />

    <node pkg="robot_state_publisher" type="robot_state_publisher" name="robot_state_publisher" output="screen">
      <param name="publish_frequency" type="double" value="50.0" />
      <param name="tf_prefix" value="$(arg first_tb3)" />
    </node>

    <node name="spawn_urdf" pkg="gazebo_ros" type="spawn_model" 
     args="-urdf -model $(arg first_tb3) -x $(arg first_tb3_x) -y $(arg first_tb3_y) -z $(arg first_tb3_z) -Y  $(arg first_tb3_yaw) -param robot_description" />
  </group>

  <group ns = "$(arg second_tb3)">
    <param name="robot_description" 
    command="$(find xacro)/xacro $(find turtlebot3_description)/urdf/turtlebot3_$(arg second_tb3_model).urdf.xacro" />

    <node pkg="robot_state_publisher" type="robot_state_publisher" name="robot_state_publisher" output="screen">
      <param name="publish_frequency" type="double" value="50.0" />
      <param name="tf_prefix" value="$(arg second_tb3)" />
    </node>

    <node name="spawn_urdf" pkg="gazebo_ros" type="spawn_model" args="-urdf -model $(arg second_tb3) -x $(arg second_tb3_x) -y $(arg second_tb3_y) -z $(arg second_tb3_z) -Y $(arg second_tb3_yaw) -param robot_description" />
  </group>
  
  <node name="view_camera_first_tb3" pkg="followbot" type="view_camera.py" respawn="false">
		<param name="camTopic" value="$(arg first_tb3_cam)" />
  </node>

  <node name="view_camera_second_tb3" pkg="followbot" type="view_camera.py" respawn="false">
		<param name="camTopic" value="$(arg second_tb3_cam)" />
  </node>

</launch>
```

Run this as
```
roslaunch turtletag demo.launch
```


### Resources
- Install the `ub_gazebo` package:  https://github.com/optimatorlab/ub_gazebo

- https://wiki.ros.org/roslaunch
    - https://wiki.ros.org/roslaunch/XML
    - https://wiki.ros.org/roslaunch/XML/node
- http://www.clearpathrobotics.com/assets/guides/noetic/ros/Launch%20Files.html
- https://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch
    - https://wiki.ros.org/ROS/Tutorials/Roslaunch%20tips%20for%20larger%20projects
- A nice example here, launching a python node:
    - https://github.com/duckietown/dt-core/blob/daffy/packages/apriltag/launch/apriltag_detector_node.launch

--- 

## 8 - Gazebo Worlds 
- https://classic.gazebosim.org/tutorials?tut=ros_roslaunch

- http://wiki.ros.org/urdf/Tutorials
- https://classic.gazebosim.org/tutorials?tut=model_editor&cat=model_editor_top#Savingyourmodel

There are other worlds already available on your machine:
```
cd /usr/share/gazebo-11/worlds
```

---

## 9 - URDF and SDF 
TODO

---

## 10 - `roslibjs`
TODO

---

## 11 - Moving Models in Gazebo/Python
TODO

--- 

## 12 - Other Robots
TODO

---

## 13 - Fun with Computer Vision
TODO

