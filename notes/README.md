# Class Notes
We'll add to this document as we progress through the semester.

---

## 1 - Viewing a simulated "Husky" robot
- See https://www.clearpathrobotics.com/assets/guides/noetic/husky/InterfacingWithHusky.html#visualization

### Start Husky Gazebo simulation:	
In Terminal 1:
```
roslaunch husky_gazebo husky_playpen.launch
```
- You can also try `roslaunch husky_gazebo empty_world.launch`, but it's pretty boring.

In Terminal 2:
```
roslaunch husky_viz view_robot.launch 
```

#### Notes:
- By default, the Husky does not publish scan or camera data.
- Take a look at `/opt/ros/noetic/share/husky_description/urdf/husky.urdf.xacro` (DO. NOT. EDIT. THIS. FILE.)
    ```
    pico /opt/ros/noetic/share/husky_description/urdf/husky.urdf.xacro 
    ```
    - `ctrl` + `x` to exit
      
- To get front/rear scanners and an RGBD camera, make sure the following environment variables are set in `~/.bashrc`:	
    ```
    export HUSKY_LMS1XX_ENABLED=1
    export HUSKY_LMS1XX_SECONDARY_ENABLED=1
    export HUSKY_REALSENSE_ENABLED=1
    export HUSKY_REALSENSE_XYZ="0.31 0 0"
    ```

    ```
    pico ~/.bashrc
    ```
    - `ctrl` + `o` to save/output
    - `ctrl` + `x` to exit

### View data in RViz	
- camera
- scan
- odom
	
The data we're visualizing here is actually being "published" by our simulated robot. 

### List topics	
```
rostopic list
```
- camera, scan, GPS, 
	
With ROS, it is possible to observe the stream of raw data directly from the terminal.
```
# Echo topic data	
rostopic echo /front/scan
```

ROS "Topics" use a publish/subscribe model/paradigm.
- publish vs subscribe	The Husky posts some data, it listens for some data
    - See `/cmd_vel`
	
ROS "Nodes"
We can visualize ROS info with `rqt`:
```
rqt
```
- plugins -> node graph


    
### Summary
What did we just see?
- Gazebo is a physics-based simulation engine
- RViz makes it easy to view the data being generated by the robot (either a real robot or a simulated robot)
- Our robot publishes data, and it also listens for data


### Before Next Class
- ~~Read~~ Study textbook Chapter 1
- Scroll through the ROS tutorials website:  http://wiki.ros.org/ROS/Tutorials
    - You don't have to do any of the tutorials yet, just take a look at the materials.

---

## 2 - Make our Husky Move
Let's see all of the topics currently being published:
```
rostopic list
```

Our Husky listens to (or, is "subscribed" to) the `cmd_vel` topic.  Let's get some information on that topic:
```
rostopic info cmd_vel
```

This produces:
```
Type: geometry_msgs/Twist
 
Publishers: None
   
Subscribers: 
* /twist_mux (http://192.168.0.209:36683/)
```

The topic "type" specifies the structure of the information being passed between "nodes".  To view the structure of the `geometry_msgs/Twist` topic type:
```
rosmsg show geometry_msgs/Twist
```

This produces:
```
geometry_msgs/Vector3 linear
  float64 x
  float64 y
  float64 z
geometry_msgs/Vector3 angular
  float64 x
  float64 y
  float64 z
```

We can publish topics directly from the terminal (command line).  
The general form is:
    - `rostopic pub /the_topic_name the_topic_type [args]`
For the Husky `cmd_vel` topic, the specific command is:    
    - `rostopic pub -r 10 /cmd_vel geometry_msgs/Twist  '{linear:  {x: 0.1, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}'`    
    
This isn't a great way to control our robot.

Let's look at some better ways.  In each of the following approaches, we're going to have some code running in the background to capture commands and send them to the robot.
This "code running in the background" is called a "node".  
A "node" is typically written in either C++ or Python.  In this class, we use Python exclusively.
- So, you can think of a node as being just a Python script that interacts with ROS.

Here's Python code for a node that publishes Twist commands randomly, every x seconds:
```
#!/usr/bin/env python3

import random
import rospy
from geometry_msgs.msg import Twist


class Publisher():
	def __init__(self):
	
		rospy.init_node("cmd_vel_publisher")

		self.cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=1)
		self.twist = Twist()

		self.rate = rospy.Rate(1/5)	# [Hz]

		self.run()
		
	def createTwistMsg(self):
		msg = Twist()
		msg.linear.x  = random.random()*5
		msg.angular.z = random.random()*5
		return msg
		
	def run(self):
		count = 0
		while count < 10:

			cmd = self.createTwistMsg()
      print(cmd)
			self.cmd_vel_pub.publish(cmd)
			
			count += 1
			
			self.rate.sleep()
			
			
if __name__ == "__main__":
	Publisher()
```

### Before Next Class
- ~~Read~~ Study textbook Chapter 2
- Continue to scroll through the ROS tutorials website:  http://wiki.ros.org/ROS/Tutorials
    - You don't have to do any of the tutorials yet, just take a look at the materials.


